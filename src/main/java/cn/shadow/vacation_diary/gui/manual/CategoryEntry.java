/*
 * This file is part of Project 42.
 *
 * Copyright 2018, Buuz135
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in the
 * Software without restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies
 * or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
 * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
package cn.shadow.vacation_diary.gui.manual;

import org.apache.commons.lang3.tuple.Pair;

import cn.shadow.vacation_diary.gui.manual.design.display.ICategoryEntryDisplay;

import java.util.ArrayList;
import java.util.List;

/**
 * Represent a Category Entry with all of its contents.
 * <p>
 * Example: {@link cn.shadow.vacation_diary.gui.manual.category.BasicCategoryEntry}
 */
public abstract class CategoryEntry {

    private List<Page> iPages;
    private List<IContent> contents;

    public CategoryEntry() {
        this.iPages = new ArrayList<>();
        this.contents = new ArrayList<>();
    }

    /**
     * Gets all the contents of a category entry has to be formatted into pages
     * @return a list of contents
     */
    public List<IContent> getContent() {
        return contents;
    }

    /**
     * Gets the display of a category to be shown in the Category Entry List GUI
     * @return a category entry display
     */
    public abstract ICategoryEntryDisplay getDisplay();

    /**
     * Gets a list of formatted pages generated by the method "generatePages"
     * @return a list of formated pages
     */
    public List<Page> getPages() {
        return iPages;
    }

    /**
     * Adds content to the Category Entry
     * @param content The content to add
     * @return itself
     */
    public CategoryEntry addContent(IContent content) {
        getContent().add(content);
        return this;
    }

    /**
     * Generates a list of pages based on the background dimensions given in {@link cn.shadow.vacation_diary.gui.manual.design.DefaultBackgroundDesign}
     * @param dimensionX How wide the content can be
     * @param dimensionY How long the content can be
     */
    public void generatePages(int dimensionX, int dimensionY) {
        this.getPages().clear();
        List<IContent> duplicateContent = new ArrayList<>(getContent());
        while (!duplicateContent.isEmpty()) {
            int currentY = 0;
            Page page = new Page();
            while (currentY < dimensionY) {
                if (duplicateContent.isEmpty()) break;
                int contentPointer = 0;
                int biggerY = 0;
                int currentX = 0;
                List<Page.FormattedContent> testContent = new ArrayList<>();
                while (currentX < dimensionX) {
                    if (contentPointer >= duplicateContent.size()) break;
                    IContent content = duplicateContent.get(contentPointer);
                    testContent.add(new Page.FormattedContent(currentX, currentY, content));
                    currentX += content.getSizeX();
                    if (content.getSizeY() > biggerY) biggerY = content.getSizeY();
                    ++contentPointer;
                }
                if (currentY + biggerY > dimensionY) {
                    int size = dimensionY - currentY;
                    int index = 0;
                    List<Page.FormattedContent> cleanedContent = new ArrayList<>();
                    for (Page.FormattedContent formattedContent : testContent) {
                        if (formattedContent.getContent().canBeSplitted()) {
                            duplicateContent.remove(formattedContent.getContent());
                            Pair<IContent, IContent> splitted = formattedContent.getContent().split(size);
                            cleanedContent.add(new Page.FormattedContent(formattedContent.getX(), formattedContent.getY(), splitted.getLeft()));
                            duplicateContent.add(index, splitted.getRight());
                        }
                        ++index;
                    }
                    testContent = cleanedContent;
                }
                currentY += biggerY;
                page.getFormattedContent().addAll(testContent);
                for (Page.FormattedContent formattedContent : testContent) {
                    duplicateContent.remove(formattedContent.getContent());
                }
            }
            if (!page.getFormattedContent().isEmpty()) getPages().add(page);
        }
    }
}
